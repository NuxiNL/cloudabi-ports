--- Lib/locale.py
+++ Lib/locale.py
@@ -340,7 +340,10 @@
 
 # store away the low-level version of setlocale (it's
 # overridden below)
-_setlocale = setlocale
+try:
+    _setlocale = setlocale
+except NameError:
+    pass
 
 def _replace_encoding(code, encoding):
     if '.' in code:
@@ -562,7 +565,7 @@
     return _parse_localename(localename)
 
 
-def getlocale(category=LC_CTYPE):
+def getlocale(category):
 
     """ Returns the current setting for the given locale category as
         tuple (language code, encoding).
@@ -597,7 +600,7 @@
         locale = normalize(_build_localename(locale))
     return _setlocale(category, locale)
 
-def resetlocale(category=LC_ALL):
+def resetlocale(category):
 
     """ Sets the locale for category to the default setting.
 
@@ -632,15 +635,18 @@
             """Return the charset that the user is likely using,
             according to the system configuration."""
             import _bootlocale
-            if do_setlocale:
-                oldloc = setlocale(LC_CTYPE)
-                try:
-                    setlocale(LC_CTYPE, "")
-                except Error:
-                    pass
-            result = _bootlocale.getpreferredencoding(False)
-            if do_setlocale:
-                setlocale(LC_CTYPE, oldloc)
+            try:
+                if do_setlocale:
+                    oldloc = setlocale(LC_CTYPE)
+                    try:
+                        setlocale(LC_CTYPE, "")
+                    except Error:
+                        pass
+                result = _bootlocale.getpreferredencoding(False)
+                if do_setlocale:
+                    setlocale(LC_CTYPE, oldloc)
+            except NameError:
+                result = _bootlocale.getpreferredencoding(False)
             return result
 
 
--- Modules/_localemodule.c
+++ Modules/_localemodule.c
@@ -44,8 +44,10 @@
 
 /* support functions for formatting floating point numbers */
 
+#ifdef HAVE_SETLOCALE
 PyDoc_STRVAR(setlocale__doc__,
 "(integer,string=None) -> string. Activates/queries locale processing.");
+#endif /* HAVE_LOCALE */
 
 /* the grouping is terminated by either 0 or CHAR_MAX */
 static PyObject*
@@ -87,6 +89,7 @@
     return result;
 }
 
+#ifdef HAVE_SETLOCALE
 static PyObject*
 PyLocale_setlocale(PyObject* self, PyObject* args)
 {
@@ -127,6 +130,7 @@
     }
     return result_object;
 }
+#endif /* HAVE_LOCALE */
 
 PyDoc_STRVAR(localeconv__doc__,
 "() -> dict. Returns numeric and monetary locale-specific parameters.");
@@ -481,6 +485,7 @@
     return PyUnicode_DecodeLocale(dgettext(domain, in), NULL);
 }
 
+#ifdef HAVE_DCGETTEXT
 PyDoc_STRVAR(dcgettext__doc__,
 "dcgettext(domain, msg, category) -> string\n"
 "Return translation of msg in domain and category.");
@@ -494,7 +499,9 @@
         return 0;
     return PyUnicode_DecodeLocale(dcgettext(domain,msgid,category), NULL);
 }
+#endif /* HAVE_DCGETTEXT */
 
+#ifdef HAVE_TEXTDOMAIN
 PyDoc_STRVAR(textdomain__doc__,
 "textdomain(domain) -> string\n"
 "Set the C library's textdmain to domain, returning the new domain.");
@@ -512,7 +519,9 @@
     }
     return PyUnicode_DecodeLocale(domain, NULL);
 }
+#endif /* HAVE_TEXTDOMAIN */
 
+#ifdef HAVE_BINDTEXTDOMAIN
 PyDoc_STRVAR(bindtextdomain__doc__,
 "bindtextdomain(domain, dir) -> string\n"
 "Bind the C library's domain to dir.");
@@ -546,6 +555,7 @@
     Py_XDECREF(dirname_bytes);
     return result;
 }
+#endif /* HAVE_BINDTEXTDOMAIN */
 
 #ifdef HAVE_BIND_TEXTDOMAIN_CODESET
 PyDoc_STRVAR(bind_textdomain_codeset__doc__,
@@ -568,8 +578,10 @@
 #endif
 
 static struct PyMethodDef PyLocale_Methods[] = {
+#ifdef HAVE_SETLOCALE
   {"setlocale", (PyCFunction) PyLocale_setlocale,
    METH_VARARGS, setlocale__doc__},
+#endif
   {"localeconv", (PyCFunction) PyLocale_localeconv,
    METH_NOARGS, localeconv__doc__},
 #ifdef HAVE_WCSCOLL
@@ -592,12 +604,18 @@
     gettext__doc__},
   {"dgettext",(PyCFunction)PyIntl_dgettext,METH_VARARGS,
    dgettext__doc__},
+#ifdef HAVE_DCGETTEXT
   {"dcgettext",(PyCFunction)PyIntl_dcgettext,METH_VARARGS,
     dcgettext__doc__},
+#endif
+#ifdef HAVE_TEXTDOMAIN
   {"textdomain",(PyCFunction)PyIntl_textdomain,METH_VARARGS,
    textdomain__doc__},
+#endif
+#ifdef HAVE_BINDTEXTDOMAIN
   {"bindtextdomain",(PyCFunction)PyIntl_bindtextdomain,METH_VARARGS,
    bindtextdomain__doc__},
+#endif
 #ifdef HAVE_BIND_TEXTDOMAIN_CODESET
   {"bind_textdomain_codeset",(PyCFunction)PyIntl_bind_textdomain_codeset,
    METH_VARARGS, bind_textdomain_codeset__doc__},
@@ -631,17 +649,29 @@
     if (m == NULL)
         return NULL;
 
+#ifdef LC_CTYPE
     PyModule_AddIntMacro(m, LC_CTYPE);
+#endif
+#ifdef LC_TIME
     PyModule_AddIntMacro(m, LC_TIME);
+#endif
+#ifdef LC_COLLATE
     PyModule_AddIntMacro(m, LC_COLLATE);
+#endif
+#ifdef LC_MONETARY
     PyModule_AddIntMacro(m, LC_MONETARY);
+#endif
 
 #ifdef LC_MESSAGES
     PyModule_AddIntMacro(m, LC_MESSAGES);
 #endif /* LC_MESSAGES */
 
+#ifdef LC_NUMERIC
     PyModule_AddIntMacro(m, LC_NUMERIC);
+#endif
+#ifdef LC_ALL
     PyModule_AddIntMacro(m, LC_ALL);
+#endif
     PyModule_AddIntMacro(m, CHAR_MAX);
 
     Error = PyErr_NewException("locale.Error", NULL, NULL);
--- Python/fileutils.c
+++ Python/fileutils.c
@@ -101,7 +101,9 @@
 static int
 check_force_ascii(void)
 {
+#ifdef HAVE_SETLOCALE
     char *loc;
+#endif /* HAVE_SETLOCALE */
 #if defined(HAVE_LANGINFO_H) && defined(CODESET)
     char *codeset, **alias;
     char encoding[20];   /* longest name: "iso_646.irv_1991\0" */
@@ -126,6 +128,7 @@
     };
 #endif
 
+#ifdef HAVE_SETLOCALE
     loc = setlocale(LC_CTYPE, NULL);
     if (loc == NULL)
         goto error;
@@ -133,6 +136,7 @@
         /* the LC_CTYPE locale is different than C */
         return 0;
     }
+#endif /* HAVE_SETLOCALE */
 
 #if defined(HAVE_LANGINFO_H) && defined(CODESET)
     codeset = nl_langinfo(CODESET);
--- Python/pylifecycle.c
+++ Python/pylifecycle.c
@@ -1245,8 +1245,10 @@
             /* When the LC_CTYPE locale is the POSIX locale ("C locale"),
                stdin and stdout use the surrogateescape error handler by
                default, instead of the strict error handler. */
+#ifdef HAVE_SETLOCALE
             char *loc = setlocale(LC_CTYPE, NULL);
             if (loc != NULL && strcmp(loc, "C") == 0)
+#endif /* HAVE_SETLOCALE */
                 errors = "surrogateescape";
         }
     }
