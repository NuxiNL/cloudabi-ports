--- src/node_wrap.h
+++ src/node_wrap.h
@@ -39,10 +39,10 @@
           env->tcp_constructor_template()->HasInstance(obj)) {                \
         TCPWrap* const wrap = Unwrap<TCPWrap>(obj);                           \
         BODY                                                                  \
-      } else if (env->tty_constructor_template().IsEmpty() == false &&        \
+      /*} else if (env->tty_constructor_template().IsEmpty() == false &&      \
                  env->tty_constructor_template()->HasInstance(obj)) {         \
         TTYWrap* const wrap = Unwrap<TTYWrap>(obj);                           \
-        BODY                                                                  \
+        BODY*/                                                                \
       } else if (env->pipe_constructor_template().IsEmpty() == false &&       \
                  env->pipe_constructor_template()->HasInstance(obj)) {        \
         PipeWrap* const wrap = Unwrap<PipeWrap>(obj);                         \
--- src/tty_wrap.cc
+++ src/tty_wrap.cc
@@ -50,6 +50,7 @@
                          Local<Context> context) {
   Environment* env = Environment::GetCurrent(context);
 
+#ifndef __CloudABI__
   Local<String> ttyString = FIXED_ONE_BYTE_STRING(env->isolate(), "TTY");
 
   Local<FunctionTemplate> t = env->NewFunctionTemplate(New);
@@ -69,16 +70,21 @@
   env->SetProtoMethod(t, "setRawMode", SetRawMode);
 
   env->SetMethod(target, "isTTY", IsTTY);
+#endif
   env->SetMethod(target, "guessHandleType", GuessHandleType);
 
+#ifndef __CloudABI__
   target->Set(ttyString, t->GetFunction());
   env->set_tty_constructor_template(t);
+#endif
 }
 
 
+#ifndef __CloudABI__
 uv_tty_t* TTYWrap::UVHandle() {
   return &handle_;
 }
+#endif
 
 
 void TTYWrap::GuessHandleType(const FunctionCallbackInfo<Value>& args) {
@@ -91,8 +97,10 @@
 
   switch (t) {
   case UV_TCP: type = "TCP"; break;
+#ifndef __CloudABI__
   case UV_TTY: type = "TTY"; break;
   case UV_UDP: type = "UDP"; break;
+#endif
   case UV_FILE: type = "FILE"; break;
   case UV_NAMED_PIPE: type = "PIPE"; break;
   case UV_UNKNOWN_HANDLE: type = "UNKNOWN"; break;
@@ -104,6 +112,7 @@
 }
 
 
+#ifndef __CloudABI__
 void TTYWrap::IsTTY(const FunctionCallbackInfo<Value>& args) {
   int fd = args[0]->Int32Value();
   CHECK_GE(fd, 0);
@@ -175,6 +184,7 @@
                       AsyncWrap::PROVIDER_TTYWRAP) {
   *init_err = uv_tty_init(env->event_loop(), &handle_, fd, readable);
 }
+#endif
 
 }  // namespace node
 
--- src/tty_wrap.h
+++ src/tty_wrap.h
@@ -36,24 +36,30 @@
                          v8::Local<v8::Value> unused,
                          v8::Local<v8::Context> context);
 
+#ifndef __CloudABI__
   uv_tty_t* UVHandle();
+#endif
 
   size_t self_size() const override { return sizeof(*this); }
 
  private:
+#ifndef __CloudABI__
   TTYWrap(Environment* env,
           v8::Local<v8::Object> object,
           int fd,
           bool readable,
           int* init_err);
+#endif
 
   static void GuessHandleType(const v8::FunctionCallbackInfo<v8::Value>& args);
+#ifndef __CloudABI__
   static void IsTTY(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void GetWindowSize(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void SetRawMode(const v8::FunctionCallbackInfo<v8::Value>& args);
   static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
 
   uv_tty_t handle_;
+#endif
 };
 
 }  // namespace node
