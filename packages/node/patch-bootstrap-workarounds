--- lib/internal/bootstrap_node.js
+++ lib/internal/bootstrap_node.js
@@ -194,7 +194,7 @@
         perf.markMilestone(
           NODE_PERFORMANCE_MILESTONE_PRELOAD_MODULE_LOAD_END);
         // If -i or --interactive were passed, or stdin is a TTY.
-        if (process._forceRepl || NativeModule.require('tty').isatty(0)) {
+        if (process._forceRepl) {
           // REPL
           const cliRepl = NativeModule.require('internal/repl');
           cliRepl.createInternalRepl(process.env, function(err, repl) {
@@ -431,7 +431,11 @@
       // getcwd(3) can fail if the current working directory has been deleted.
       // Fall back to the directory name of the (absolute) executable path.
       // It's not really correct but what are the alternatives?
-      return path.dirname(process.execPath);
+      try {
+        return path.dirname(process.execPath);
+      } catch (ex) {
+        return '/unknown';
+      }
     }
   }
 
--- lib/module.js
+++ lib/module.js
@@ -713,7 +713,6 @@
     parent.require(requests[n]);
 };
 
-Module._initPaths();
 
 // backwards compatibility
 Module.Module = Module;
--- lib/repl.js
+++ lib/repl.js
@@ -81,8 +81,12 @@
   // path.resolve('repl') fails when the current working directory has been
   // deleted.  Fall back to the directory name of the (absolute) executable
   // path.  It's not really correct but what are the alternatives?
-  const dirname = path.dirname(process.execPath);
-  module.filename = path.resolve(dirname, 'repl');
+  try {
+    const dirname = path.dirname(process.execPath);
+    module.filename = path.resolve(dirname, 'repl');
+  } catch (e) {
+    module.filename = '/';
+  }
 }
 
 // hack for repl require to work properly with node_modules folders
