--- include/libircclient.h
+++ include/libircclient.h
@@ -278,6 +278,50 @@ int irc_connect6 (irc_session_t * session,
 			const char * realname);
 
 /*!
+ * \fn int irc_set_sockfd (irc_session_t * session, int fd, int ssl, const char * server_password, const char * nick, const char * username, const char * realname);
+ * \brief Adopts a given socket file descriptor to the IRC server.
+ *
+ * \param session A session to adopt the socket to. Must not be NULL.
+ * \param fd      The socket file descriptor to adopt. Must already be connected.
+ * \param ssl     If set to 1 and the library is built with SSL support, tries to perform an SSL handshake on the socket first.
+ * \param server_password  An IRC server password, if the server requires it.
+ *                May be NULL, in this case password will not be send to the 
+ *                IRC server. Vast majority of IRC servers do not require passwords.
+ * \param nick    A nick, which libircclient will use to login to the IRC server.
+ *                Must not be NULL.
+ * \param username A username of the account, which is used to connect to the
+ *                IRC server. This is for information only, will be shown in
+ *                "user properties" dialogs and returned by /whois request.
+ *                May be NULL, in this case 'nobody' will be sent as username.
+ * \param realname A real name of the person, who connects to the IRC. Usually
+ *                people put some wide-available information here (URL, small
+ *                description or something else). This information also will 
+ *                be shown in "user properties" dialogs and returned by /whois 
+ *                request. May be NULL, in this case 'noname' will be sent as 
+ *                username.
+ *
+ * \return Return code 0 means success. Other value means error, the error
+ *  code may be obtained through irc_errno(). Any error, generated by the
+ *  IRC server, is available through irc_callbacks_t::event_numeric.
+ *
+ * This function adopts a file descriptor already connected to an IRC server.
+ * It performs an SSL handshake if necessary, then starts the handshake with
+ * the IRC server. You can use this function if you already have a file
+ * descriptor to an IRC server, and especially if your platform has no
+ * socket() or connect() function, e.g. CloudABI.
+ * 
+ * \sa irc_run
+ * \ingroup conndisc
+ */
+int irc_set_sockfd (irc_session_t * session,
+			int fd,
+			int ssl,
+			const char * server_password,
+			const char * nick,
+			const char * username,
+			const char * realname);
+
+/*!
  * \fn void irc_disconnect (irc_session_t * session)
  * \brief Disconnects a connection to IRC server.
  *
--- src/Makefile.in
+++ src/Makefile.in
@@ -17,12 +17,14 @@ shared_mingw: libircclient.dll
 
 install:
 	-mkdir -p $(DESTDIR)@prefix@/include
+	-mkdir -p $(DESTDIR)@prefix@/lib
 	-mkdir -p $(DESTDIR)@libdir@
 	cp ../include/libircclient.h $(DESTDIR)@prefix@/include/libircclient.h
 	cp ../include/libirc_errors.h $(DESTDIR)@prefix@/include/libirc_errors.h
 	cp ../include/libirc_events.h  $(DESTDIR)@prefix@/include/libirc_events.h 
 	cp ../include/libirc_options.h  $(DESTDIR)@prefix@/include/libirc_options.h 
 	cp ../include/libirc_rfcnumeric.h  $(DESTDIR)@prefix@/include/libirc_rfcnumeric.h 
+	cp libircclient.a $(DESTDIR)@prefix@/lib/libircclient.a
 	cp libircclient.so $(DESTDIR)@libdir@/libircclient.so.$(APIVERSION)
 	ln -fs libircclient.so.$(APIVERSION) $(DESTDIR)@libdir@/libircclient.so
 
--- src/dcc.c
+++ src/dcc.c
@@ -16,7 +16,7 @@
 #define LIBIRC_DCC_SENDFILE		2
 #define LIBIRC_DCC_RECVFILE		3
 
-
+#if !defined(__CloudABI__)
 static irc_dcc_session_t * libirc_find_dcc_session (irc_session_t * session, irc_dcc_t dccid, int lock_list)
 {
 	irc_dcc_session_t * s, *found = 0;
@@ -895,3 +895,4 @@ int	irc_dcc_sendfile (irc_session_t * session, void * ctx, const char * nick, co
 
 	return 0;
 }
+#endif
--- src/libircclient.c
+++ src/libircclient.c
@@ -131,12 +131,14 @@ void irc_destroy_session (irc_session_t * session)
 		SSL_free( session->ssl );
 #endif
 	
+#if !defined (__CloudABI__)
 	/* 
 	 * delete DCC data 
 	 * libirc_remove_dcc_session removes the DCC session from the list.
 	 */
 	while ( session->dcc_sessions )
 		libirc_remove_dcc_session (session, session->dcc_sessions, 0);
+#endif
 
 	libirc_mutex_destroy (&session->mutex_dcc);
 
@@ -149,6 +151,7 @@ void irc_destroy_session (irc_session_t * session)
 }
 
 
+#if !defined(__CloudABI__)
 int irc_connect (irc_session_t * session,
 			const char * server, 
 			unsigned short port,
@@ -432,6 +435,82 @@ int irc_connect6 (irc_session_t * session,
 	return 1;
 #endif	
 }
+#endif
+
+#if !defined (_WIN32)
+int irc_set_sockfd (irc_session_t * session,
+			int fd,
+			int ssl,
+			const char * server_password,
+			const char * nick,
+			const char * username,
+			const char * realname)
+{
+	// Check and copy all the specified fields
+	if ( !nick )
+	{
+		session->lasterror = LIBIRC_ERR_INVAL;
+		return 1;
+	}
+
+	if ( session->state != LIBIRC_STATE_INIT )
+	{
+		session->lasterror = LIBIRC_ERR_STATE;
+		return 1;
+	}
+
+	// Free the strings if defined; may be the case when the session is reused after the connection fails
+	free_ircsession_strings( session );
+
+	// Handle the server # prefix (SSL)
+	if ( ssl )
+	{
+#if defined (ENABLE_SSL)
+		session->flags |= SESSIONFL_SSL_CONNECTION;
+#else
+		session->lasterror = LIBIRC_ERR_SSL_NOT_SUPPORTED;
+		return 1;
+#endif
+	}
+	
+	if ( username )
+		session->username = strdup (username);
+
+	if ( server_password )
+		session->server_password = strdup (server_password);
+
+	if ( realname )
+		session->realname = strdup (realname);
+
+	session->nick = strdup (nick);
+	session->server = NULL;
+
+	session->sock = fd;
+	if ( socket_make_nonblocking (&session->sock) )
+	{
+		session->lasterror = LIBIRC_ERR_SOCKET;
+		return 1;
+	}
+
+#if defined (ENABLE_SSL)
+	// Init the SSL stuff
+	if ( session->flags & SESSIONFL_SSL_CONNECTION )
+	{
+		int rc = ssl_init( session );
+		
+		if ( rc != 0 )
+		{
+			session->lasterror = rc;
+			return 1;
+		}
+	}
+#endif
+	
+    session->state = LIBIRC_STATE_CONNECTING;
+    session->flags = 0; // reset in case of reconnect
+	return 0;
+}
+#endif
 
 
 int irc_is_connected (irc_session_t * session)
@@ -516,7 +595,9 @@ int irc_add_select_descriptors (irc_session_t * session, fd_set *in_set, fd_set
 
 	libirc_mutex_unlock (&session->mutex_session);
 
+#if !defined(__CloudABI__)
 	libirc_dcc_add_descriptors (session, in_set, out_set, maxfd);
+#endif
 	return 0;
 }
 
@@ -723,9 +804,12 @@ static void libirc_process_incoming_data (irc_session_t * session, size_t proces
 					memcpy (ctcp_buf, params[1] + 1, msglen);
 					ctcp_buf[msglen] = '\0';
 
+#if !defined(__CloudABI__)
 					if ( !strncasecmp(ctcp_buf, "DCC ", 4) )
 						libirc_dcc_request (session, prefix, ctcp_buf);
-					else if ( !strncasecmp( ctcp_buf, "ACTION ", 7)
+					else
+#endif
+					if ( !strncasecmp( ctcp_buf, "ACTION ", 7)
 					&& session->callbacks.event_ctcp_action )
 					{
 						params[1] = ctcp_buf + 7; // the length of "ACTION "
@@ -814,7 +898,7 @@ static void libirc_process_incoming_data (irc_session_t * session, size_t proces
 
 int irc_process_select_descriptors (irc_session_t * session, fd_set *in_set, fd_set *out_set)
 {
-	char buf[256], hname[256];
+	char buf[256];
 
 	if ( session->sock < 0 
 	|| session->state == LIBIRC_STATE_INIT
@@ -825,7 +909,9 @@ int irc_process_select_descriptors (irc_session_t * session, fd_set *in_set, fd_
 	}
 
 	session->lasterror = 0;
+#if !defined(__CloudABI__)
 	libirc_dcc_process_descriptors (session, in_set, out_set);
+#endif
 
 	// Handle "connection succeed" / "connection failed"
 	if ( session->state == LIBIRC_STATE_CONNECTING )
@@ -834,6 +920,7 @@ int irc_process_select_descriptors (irc_session_t * session, fd_set *in_set, fd_
         if ( !FD_ISSET (session->sock, out_set) )
             return 0;
         
+#if !defined(__CloudABI__)
 		// Now we have to determine whether the socket is connected 
 		// or the connect is failed
 		struct sockaddr_storage saddr, laddr;
@@ -859,11 +946,11 @@ int irc_process_select_descriptors (irc_session_t * session, fd_set *in_set, fd_
 			fprintf (stderr, "[DEBUG] Detected local address: %s\n", inet_ntoa(session->local_addr));
 #endif
 
-		session->state = LIBIRC_STATE_CONNECTED;
+#else /* defined(__CloudABI__) */
+		// Assume it's already connected
+#endif
 
-		// Get the hostname
-    	if ( gethostname (hname, sizeof(hname)) < 0 )
-    		strcpy (hname, "unknown");
+		session->state = LIBIRC_STATE_CONNECTED;
 
 		// Prepare the data, which should be sent to the server
 		if ( session->server_password )
--- src/portable.c
+++ src/portable.c
@@ -18,6 +18,7 @@
 	#include <stdarg.h>
 	#include <unistd.h>
 	#include <string.h>
+	#include <strings.h>
 	#include <stdlib.h>
 	#include <sys/stat.h>
 	#include <sys/types.h>
--- src/sockets.c
+++ src/sockets.c
@@ -64,11 +64,13 @@ static int socket_error()
 }
 
 
+#if !defined (__CloudABI__)
 static int socket_create (int domain, int type, socket_t * sock)
 {
 	*sock = socket (domain, type, 0);
 	return IS_SOCKET_ERROR(*sock) ? 1 : 0;
 }
+#endif
 
 
 static int socket_make_nonblocking (socket_t * sock)
@@ -95,6 +97,7 @@ static int socket_close (socket_t * sock)
 }
 
 
+#if !defined (__CloudABI__)
 static int socket_connect (socket_t * sock, const struct sockaddr *saddr, socklen_t len)
 {
 	while ( 1 )
@@ -125,6 +128,7 @@ static int socket_accept (socket_t * sock, socket_t * newsock, struct sockaddr *
 
 	return 0;
 }
+#endif
 
 
 static int socket_recv (socket_t * sock, void * buf, size_t len)
--- src/utils.c
+++ src/utils.c
@@ -23,9 +23,9 @@ static void libirc_add_to_set (int fd, fd_set *set, int * maxfd)
 #if defined (ENABLE_DEBUG)
 static void libirc_dump_data (const char * prefix, const char * buf, unsigned int length)
 {
-	printf ("%s: ", prefix);
+	fprintf (stderr, "%s: ", prefix);
 	for ( ; length > 0; length -- )
-		printf ("%c", *buf++);
+		fprintf (stderr, "%c", *buf++);
 }
 #endif
 
@@ -59,6 +59,7 @@ static int libirc_findcrlf_offset(const char *buf, int offset, const int length)
 	return offset;
 }
 
+#if !defined (__CloudABI__)
 static int libirc_findcrorlf (char * buf, int length)
 {
 	int offset = 0;
@@ -78,6 +79,7 @@ static int libirc_findcrorlf (char * buf, int length)
 
 	return 0;
 }
+#endif
 
 
 static void libirc_event_ctcp_internal (irc_session_t * session, const char * event, const char * origin, const char ** params, unsigned int count)
