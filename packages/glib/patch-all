--- glib/gbacktrace.c
+++ glib/gbacktrace.c
@@ -44,7 +44,6 @@
 
 #ifdef G_OS_UNIX
 #include <unistd.h>
-#include <sys/wait.h>
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif /* HAVE_SYS_SELECT_H */
@@ -80,7 +79,7 @@
 #endif
 
 
-#ifndef G_OS_WIN32
+#if !defined(G_OS_WIN32) && !defined(__CloudABI__)
 static void stack_trace (char **args);
 #endif
 
@@ -141,6 +140,9 @@
 void
 g_on_error_query (const gchar *prg_name)
 {
+#ifdef __CloudABI__
+  abort();
+#else
 #ifndef G_OS_WIN32
   static const gchar * const query1 = "[E]xit, [H]alt";
   static const gchar * const query2 = ", show [S]tack trace";
@@ -205,6 +207,7 @@
               MB_OK|MB_ICONERROR);
   _exit(0);
 #endif
+#endif
 }
 
 /**
@@ -223,6 +226,9 @@
 void
 g_on_error_stack_trace (const gchar *prg_name)
 {
+#ifdef __CloudABI__
+  abort();
+#else
 #if defined(G_OS_UNIX)
   pid_t pid;
   gchar buf[16];
@@ -256,6 +262,7 @@
   else
     abort ();
 #endif
+#endif
 }
 
 #ifndef G_OS_WIN32
@@ -268,6 +275,7 @@
   stack_trace_done = TRUE;
 }
 
+#ifndef __CloudABI__
 static void
 stack_trace (char **args)
 {
@@ -373,5 +381,6 @@
   close (out_fd[1]);
   _exit (0);
 }
+#endif
 
 #endif /* !G_OS_WIN32 */
--- glib/gfileutils.c
+++ glib/gfileutils.c
@@ -205,6 +205,7 @@
  *
  * Since: 2.8
  */
+#ifndef __CloudABI__
 int
 g_mkdir_with_parents (const gchar *pathname,
 		      int          mode)
@@ -263,6 +264,7 @@
 
   return 0;
 }
+#endif
 
 /**
  * g_file_test:
@@ -313,6 +315,7 @@
  *
  * Returns: whether a test was %TRUE
  **/
+#ifndef __CloudABI__
 gboolean
 g_file_test (const gchar *filename,
              GFileTest    test)
@@ -457,6 +460,7 @@
   return FALSE;
 #endif
 }
+#endif
 
 G_DEFINE_QUARK (g-file-error-quark, g_file_error)
 
@@ -762,6 +766,7 @@
   return FALSE;
 }
 
+#ifndef __CloudABI__
 #ifndef G_OS_WIN32
 
 static gboolean
@@ -1255,6 +1260,7 @@
   g_free (tmp_filename);
   return retval;
 }
+#endif
 
 /*
  * get_tmp_file based on the mkstemp implementation from the GNU C library.
@@ -1331,6 +1337,7 @@
  * they appear compatible, they may be vararg functions and calling
  * varargs functions through a non-varargs type is undefined.
  */
+#ifndef __CloudABI__
 static gint
 wrap_g_mkdir (const gchar *filename,
               int          flags G_GNUC_UNUSED,
@@ -1471,6 +1478,7 @@
 {
   return g_mkstemp_full (tmpl, O_RDWR | O_BINARY, 0600);
 }
+#endif
 
 static gint
 g_get_tmp_name (const gchar      *tmpl,
@@ -1578,6 +1586,7 @@
  *     where there is a difference. The file handle should be closed with
  *     close(). In case of errors, -1 is returned and @error will be set.
  */
+#ifndef __CloudABI__
 gint
 g_file_open_tmp (const gchar  *tmpl,
                  gchar       **name_used,
@@ -1601,6 +1610,7 @@
 
   return result;
 }
+#endif
 
 /**
  * g_dir_make_tmp:
@@ -1627,6 +1637,7 @@
  *
  * Since: 2.30
  */
+#ifndef __CloudABI__
 gchar *
 g_dir_make_tmp (const gchar  *tmpl,
                 GError      **error)
@@ -1638,6 +1649,7 @@
   else
     return fulltemplate;
 }
+#endif
 
 static gchar *
 g_build_path_va (const gchar  *separator,
@@ -2432,6 +2444,7 @@
  *
  * Returns: the current directory
  */
+#ifndef __CloudABI__
 gchar *
 g_get_current_dir (void)
 {
@@ -2499,6 +2512,7 @@
 
 #endif /* !G_OS_WIN32 */
 }
+#endif
 
 
 /* NOTE : Keep this part last to ensure nothing in this file uses thn
--- glib/gfileutils.h
+++ glib/gfileutils.h
@@ -79,45 +79,19 @@
 GFileError g_file_error_from_errno (gint err_no);
 
 GLIB_AVAILABLE_IN_ALL
-gboolean g_file_test         (const gchar  *filename,
-                              GFileTest     test);
-GLIB_AVAILABLE_IN_ALL
 gboolean g_file_get_contents (const gchar  *filename,
                               gchar       **contents,
                               gsize        *length,
                               GError      **error);
 GLIB_AVAILABLE_IN_ALL
-gboolean g_file_set_contents (const gchar *filename,
-                              const gchar *contents,
-                              gssize         length,
-                              GError       **error);
-GLIB_AVAILABLE_IN_ALL
 gchar   *g_file_read_link    (const gchar  *filename,
                               GError      **error);
 
 /* Wrapper / workalike for mkdtemp() */
-GLIB_AVAILABLE_IN_2_30
-gchar   *g_mkdtemp            (gchar        *tmpl);
-GLIB_AVAILABLE_IN_2_30
-gchar   *g_mkdtemp_full       (gchar        *tmpl,
-                               gint          mode);
 
 /* Wrapper / workalike for mkstemp() */
-GLIB_AVAILABLE_IN_ALL
-gint     g_mkstemp            (gchar        *tmpl);
-GLIB_AVAILABLE_IN_ALL
-gint     g_mkstemp_full       (gchar        *tmpl,
-                               gint          flags,
-                               gint          mode);
 
 /* Wrappers for g_mkstemp and g_mkdtemp() */
-GLIB_AVAILABLE_IN_ALL
-gint     g_file_open_tmp      (const gchar  *tmpl,
-                               gchar       **name_used,
-                               GError      **error);
-GLIB_AVAILABLE_IN_2_30
-gchar   *g_dir_make_tmp       (const gchar  *tmpl,
-                               GError      **error);
 
 GLIB_AVAILABLE_IN_ALL
 gchar   *g_build_path         (const gchar *separator,
@@ -133,9 +107,6 @@
 GLIB_AVAILABLE_IN_ALL
 gchar   *g_build_filenamev    (gchar      **args) G_GNUC_MALLOC;
 
-GLIB_AVAILABLE_IN_ALL
-gint     g_mkdir_with_parents (const gchar *pathname,
-                               gint         mode);
 
 #ifdef G_OS_WIN32
 
@@ -171,8 +142,6 @@
 #endif
 
 GLIB_AVAILABLE_IN_ALL
-gchar *g_get_current_dir   (void);
-GLIB_AVAILABLE_IN_ALL
 gchar *g_path_get_basename (const gchar *file_name) G_GNUC_MALLOC;
 GLIB_AVAILABLE_IN_ALL
 gchar *g_path_get_dirname  (const gchar *file_name) G_GNUC_MALLOC;
--- glib/glib-unix.h
+++ glib/glib-unix.h
@@ -26,7 +26,6 @@
  */
 #include <unistd.h>
 #include <errno.h>
-#include <sys/wait.h>
 #include <stdlib.h>
 #include <fcntl.h>
 
--- glib/glib.h
+++ glib/glib.h
@@ -75,7 +75,6 @@
 #include <glib/gshell.h>
 #include <glib/gslice.h>
 #include <glib/gslist.h>
-#include <glib/gspawn.h>
 #include <glib/gstrfuncs.h>
 #include <glib/gstring.h>
 #include <glib/gstringchunk.h>
--- glib/gspawn.c
+++ glib/gspawn.c
@@ -1,3 +1,4 @@
+#ifndef __CloudABI__
 /* gspawn.c - Process launching
  *
  *  Copyright 2000 Red Hat, Inc.
@@ -1816,3 +1817,4 @@
 g_spawn_close_pid (GPid pid)
 {
 }
+#endif
--- glib/gspawn.h
+++ glib/gspawn.h
@@ -1,3 +1,4 @@
+#error "Process spawning not supported in this environment"
 /* gspawn.h - Process launching
  *
  *  Copyright 2000 Red Hat, Inc.
--- glib/gtester.c
+++ glib/gtester.c
@@ -24,7 +24,6 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <fcntl.h>
-#include <sys/wait.h>
 #include <errno.h>
 #include <signal.h>
 
--- glib/gtestutils.c
+++ glib/gtestutils.c
@@ -23,7 +23,6 @@
 
 #include <sys/types.h>
 #ifdef G_OS_UNIX
-#include <sys/wait.h>
 #include <sys/time.h>
 #include <fcntl.h>
 #include <unistd.h>
@@ -51,7 +50,6 @@
 #include "gstrfuncs.h"
 #include "gtimer.h"
 #include "gslice.h"
-#include "gspawn.h"
 #include "glib-private.h"
 
 
@@ -910,7 +908,6 @@
   guint i, e;
 
   test_argv0 = argv[0];
-  test_initial_cwd = g_get_current_dir ();
 
   /* parse known args */
   for (i = 1; i < argc; i++)
@@ -2611,7 +2608,7 @@
 {
   WaitForChildData *data = user_data;
 
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(__CloudABI__)
   if (WIFEXITED (status)) /* normal exit */
     data->child_status = WEXITSTATUS (status); /* 0..255 */
   else if (WIFSIGNALED (status) && WTERMSIG (status) == SIGALRM)
@@ -2632,11 +2629,13 @@
 {
   WaitForChildData *data = user_data;
 
+#ifndef __CloudABI__
 #ifdef G_OS_WIN32
   TerminateProcess (data->pid, G_TEST_STATUS_TIMED_OUT);
 #else
   kill (data->pid, SIGALRM);
 #endif
+#endif
 
   return FALSE;
 }
@@ -2691,6 +2690,7 @@
   return TRUE;
 }
 
+#ifndef __CloudABI__
 static void
 wait_for_child (GPid pid,
                 int stdout_fd, gboolean echo_stdout,
@@ -2755,6 +2755,7 @@
   g_clear_pointer (&data.stdout_io, g_io_channel_unref);
   g_clear_pointer (&data.stderr_io, g_io_channel_unref);
 }
+#endif
 
 /**
  * g_test_trap_fork:
@@ -2802,7 +2803,7 @@
 g_test_trap_fork (guint64        usec_timeout,
                   GTestTrapFlags test_trap_flags)
 {
-#ifdef G_OS_UNIX
+#if defined(G_OS_UNIX) && !defined(__CloudABI__)
   int stdout_pipe[2] = { -1, -1 };
   int stderr_pipe[2] = { -1, -1 };
 
@@ -2927,6 +2928,9 @@
                         guint64               usec_timeout,
                         GTestSubprocessFlags  test_flags)
 {
+#ifdef __CloudABI__
+  g_error ("g_test_trap_subprocess: not implemented");
+#else
   GError *error = NULL;
   GPtrArray *argv;
   GSpawnFlags flags;
@@ -2988,6 +2992,7 @@
                   stdout_fd, !!(test_flags & G_TEST_SUBPROCESS_INHERIT_STDOUT),
                   stderr_fd, !!(test_flags & G_TEST_SUBPROCESS_INHERIT_STDERR),
                   usec_timeout);
+#endif
 }
 
 /**
--- glib/gutils.c
+++ glib/gutils.c
@@ -39,7 +39,6 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #ifdef G_OS_UNIX
-#include <pwd.h>
 #include <unistd.h>
 #endif
 #include <sys/types.h>
@@ -325,6 +324,7 @@
  *
  * Returns: a newly-allocated string with the absolute path, or %NULL
  **/
+#ifndef __CloudABI__
 #ifdef G_OS_WIN32
 static gchar *
 inner_find_program_in_path (const gchar *program)
@@ -482,6 +482,7 @@
 
   return NULL;
 }
+#endif
 
 /**
  * g_bit_nth_lsf:
@@ -531,6 +532,7 @@
   gchar *home_dir;
 } UserDatabaseEntry;
 
+#ifndef __CloudABI__
 static  gchar   *g_user_data_dir = NULL;
 static  gchar  **g_system_data_dirs = NULL;
 static  gchar   *g_user_cache_dir = NULL;
@@ -538,6 +540,7 @@
 static  gchar  **g_system_config_dirs = NULL;
 
 static  gchar  **g_user_special_dirs = NULL;
+#endif
 
 /* fifteen minutes of fame for everybody */
 #define G_USER_DIRS_EXPIRE      15 * 60
@@ -593,6 +596,7 @@
 #endif
 
 /* HOLDS: g_utils_global_lock */
+#ifndef __CloudABI__
 static UserDatabaseEntry *
 g_get_user_database_entry (void)
 {
@@ -783,6 +787,7 @@
 
   return entry->real_name;
 }
+#endif
 
 /**
  * g_get_home_dir:
@@ -810,6 +815,7 @@
  *
  * Returns: the current user's home directory
  */
+#ifndef __CloudABI__
 const gchar *
 g_get_home_dir (void)
 {
@@ -885,6 +891,7 @@
 
   return home_dir;
 }
+#endif
 
 /**
  * g_get_tmp_dir:
@@ -971,6 +978,7 @@
  *
  * Since: 2.8
  */
+#ifndef __CloudABI__
 const gchar *
 g_get_host_name (void)
 {
@@ -993,6 +1001,7 @@
 
   return hostname;
 }
+#endif
 
 G_LOCK_DEFINE_STATIC (g_prgname);
 static gchar *g_prgname = NULL;
@@ -1150,6 +1159,7 @@
  *               or freed.
  * Since: 2.6
  **/
+#ifndef __CloudABI__
 const gchar *
 g_get_user_data_dir (void)
 {
@@ -1732,6 +1742,7 @@
 
   return g_user_special_dirs[directory];
 }
+#endif
 
 #ifdef G_OS_WIN32
 
@@ -1925,6 +1936,7 @@
  *               not be modified or freed.
  * Since: 2.6
  **/
+#ifndef __CloudABI__
 const gchar * const * 
 g_get_system_data_dirs (void)
 {
@@ -2015,6 +2027,7 @@
 
   return (const gchar * const *) conf_dir_vector;
 }
+#endif
 
 /**
  * g_nullify_pointer:
--- glib/gutils.h
+++ glib/gutils.h
@@ -83,16 +83,8 @@
 #endif /* !G_INLINE_FUNC */
 
 GLIB_AVAILABLE_IN_ALL
-const gchar *         g_get_user_name        (void);
-GLIB_AVAILABLE_IN_ALL
-const gchar *         g_get_real_name        (void);
-GLIB_AVAILABLE_IN_ALL
-const gchar *         g_get_home_dir         (void);
-GLIB_AVAILABLE_IN_ALL
 const gchar *         g_get_tmp_dir          (void);
 GLIB_AVAILABLE_IN_ALL
-const gchar *         g_get_host_name	     (void);
-GLIB_AVAILABLE_IN_ALL
 const gchar *         g_get_prgname          (void);
 GLIB_AVAILABLE_IN_ALL
 void                  g_set_prgname          (const gchar *prgname);
@@ -102,14 +94,6 @@
 void                  g_set_application_name (const gchar *application_name);
 
 GLIB_AVAILABLE_IN_ALL
-void      g_reload_user_special_dirs_cache     (void);
-GLIB_AVAILABLE_IN_ALL
-const gchar *         g_get_user_data_dir      (void);
-GLIB_AVAILABLE_IN_ALL
-const gchar *         g_get_user_config_dir    (void);
-GLIB_AVAILABLE_IN_ALL
-const gchar *         g_get_user_cache_dir     (void);
-GLIB_AVAILABLE_IN_ALL
 const gchar * const * g_get_system_data_dirs   (void);
 
 #ifdef G_OS_WIN32
@@ -131,11 +115,7 @@
 #define g_get_system_data_dirs _g_win32_get_system_data_dirs
 #endif
 
-GLIB_AVAILABLE_IN_ALL
-const gchar * const * g_get_system_config_dirs (void);
 
-GLIB_AVAILABLE_IN_ALL
-const gchar * g_get_user_runtime_dir (void);
 
 /**
  * GUserDirectory:
@@ -172,8 +152,6 @@
   G_USER_N_DIRECTORIES
 } GUserDirectory;
 
-GLIB_AVAILABLE_IN_ALL
-const gchar * g_get_user_special_dir (GUserDirectory directory);
 
 /**
  * GDebugKey:
@@ -258,8 +236,6 @@
 
 
 /* Look for an executable in PATH, following execvp() rules */
-GLIB_AVAILABLE_IN_ALL
-gchar*  g_find_program_in_path  (const gchar *program);
 
 /* Bit tests
  */
--- gmodule/gmodule.c
+++ gmodule/gmodule.c
@@ -336,6 +336,7 @@
   return TRUE;
 }
 
+#ifndef __CloudABI__
 static gchar*
 parse_libtool_archive (const gchar* libtool_name)
 {
@@ -425,6 +426,7 @@
 
   return name;
 }
+#endif
 
 static inline gboolean
 str_check_suffix (const gchar* string,
@@ -516,6 +518,7 @@
       return module;
     }
 
+#ifndef __CloudABI__
   /* check whether we have a readable file right away */
   if (g_file_test (file_name, G_FILE_TEST_IS_REGULAR))
     name = g_strdup (file_name);
@@ -539,6 +542,7 @@
 	  name = NULL;
 	}
     }
+#endif
   /* we can't access() the file, lets hope the platform backends finds
    * it via library paths
    */
@@ -558,6 +562,7 @@
   if (name)
     {
       /* if it's a libtool archive, figure library file to load */
+#ifndef __CloudABI__
       if (str_check_suffix (name, ".la")) /* libtool archive? */
 	{
 	  gchar *real_name = parse_libtool_archive (name);
@@ -569,6 +574,7 @@
 	      name = real_name;
             }
 	}
+#endif
       if (name)
 	handle = _g_module_open (name, (flags & G_MODULE_BIND_LAZY) != 0,
 			(flags & G_MODULE_BIND_LOCAL) != 0);
