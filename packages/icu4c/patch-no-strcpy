--- source/common/cstring.h
+++ source/common/cstring.h
@@ -31,10 +31,18 @@
 #include <stdlib.h>
 #include <ctype.h>
 
+#ifdef __CloudABI__
+#define uprv_strcpy(dst, src) strlcpy(dst, src, SIZE_MAX)
+#else
 #define uprv_strcpy(dst, src) U_STANDARD_CPP_NAMESPACE  strcpy(dst, src)
+#endif
 #define uprv_strlen(str) U_STANDARD_CPP_NAMESPACE strlen(str)
 #define uprv_strcmp(s1, s2) U_STANDARD_CPP_NAMESPACE strcmp(s1, s2)
+#ifdef __CloudABI__
+#define uprv_strcat(dst, src) strlcat(dst, src, SIZE_MAX)
+#else
 #define uprv_strcat(dst, src) U_STANDARD_CPP_NAMESPACE strcat(dst, src)
+#endif
 #define uprv_strchr(s, c) U_STANDARD_CPP_NAMESPACE strchr(s, c)
 #define uprv_strstr(s, c) U_STANDARD_CPP_NAMESPACE strstr(s, c)
 #define uprv_strrchr(s, c) U_STANDARD_CPP_NAMESPACE strrchr(s, c)
--- source/i18n/decNumber.c
+++ source/i18n/decNumber.c
@@ -3668,15 +3668,14 @@
     }
   if (dn->bits&DECSPECIAL) {       /* Is a special value  */
     if (decNumberIsInfinite(dn)) {
-      strcpy(c,   "Inf");
-      strcpy(c+3, "inity");
+      memcpy(c, "Infinity", 9);
       return;}
     /* a NaN  */
     if (dn->bits&DECSNAN) {        /* signalling NaN  */
       *c='s';
       c++;
       }
-    strcpy(c, "NaN");
+    memcpy(c, "NaN", 4);
     c+=3;                          /* step past  */
     /* if not a clean non-zero coefficient, that's all there is in a  */
     /* NaN string  */
--- source/i18n/ucol_sit.cpp
+++ source/i18n/ucol_sit.cpp
@@ -373,7 +373,7 @@
                 } else {
                     len += s->entries[i].len;
                     if(len < capacity) {
-                        uprv_strncat(destination,s->entries[i].start, s->entries[i].len);
+                        uprv_memcpy(destination + (len - s->entries[i].len), s->entries[i].start, s->entries[i].len);
                     }
                 }
             }
